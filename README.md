# Spring_Shpora
Bean – объект бизнес-логики в терминологии Spring Framework.

BeanDefinition – декларация, описание того, как создавать бин. Объект хранит его тип,
метаинформацию, набор параметров для конструктора.

BeanFactory – главная точка входа в DI-контейнер. Хранит BeanDefinition-ы, умеет
создавать по ним экземпляры бинов, или выдавать существующие, в зависимости от
области видимости Scope.

BeanPostProcessor – до-настраивает только что созданные бины, ПЕРЕД тем как
положить их в контейнер. Типичное место, чтобы оборачивать бины в прокси.
Также с помощью такого постпроцессора внедряются @Autowired зависимости.
Постпроцессоры бинов живут внутри экземпляра BeanFactory.

BeanFactoryPostProcessor – тоже пост-обработчик, но для деклараций бинов
(BeanDefinition). Обычно используется для модификации параметров или класса, из
которых будут строиться бины.

Для создания определений бинов в основном применяются классы и интерфейсы
*BeanDefinitionReader. Некоторые из них вызываются прямо из контекста приложения,
другие реализуют BeanFactoryPostProcessor. Один такой пост-процессор, например,
отвечает за добавление определений бинов по аннотациям @Component
и @Configuration.

Реализация интерфейса ApplicationContext – основное хранилище конфигурации
Spring-приложения (или его части). Контекст неизменяем, но может быть целиком
перезагружен. Xml-файл конфигурации на старте приложения превращается в
объект *XmlApplicationContext.
Для конфигурации на аннотациях создастся AnnotationConfigApplicationContext .
Контекст выполняет четыре разных обязанности:

1. DI-контейнер. ApplicationContext функционирует как специальная реализация
BeanFactory. Он также производит и хранит бины, но, в отличие от обычных фабрик,
контексты в приложении составляют иерархию. Определения бинов из дочерних
контекстов перекрывают родительские.

2. Загрузка ресурсов. Под интерфейсом ResourceLoader контекст занимается
загрузкой в память приложения файлов, как из classpath, так и из остальной файловой
системы.

3. Публикация событий приложения. Контекст распространяет в приложении
«события» – наследники ApplicationEvent. Любой бин, которому нужно получать
уведомления об этих событиях, просто реализует интерфейс ApplicationListener.
Таким образом реализуется паттерн наблюдатель.

4. Интернационализация. По коду, набору аргументов и локали, через интерфейс
контекста MessageSource можно получать локализованные текстовые сообщения для
пользователей.

Dependency Injection (DI) – это ЧАСТЬ Inversion of Control (IoC), не взаимозаменяемы!
Инверсия контроля (inversion of control, IoC) – принцип проектирования, по которому
контроль над потоком управления передается фреймворку. Управляющий и прикладной
код разделяются. При разработке модуля этот подход избавляет от необходимости знать
о других модулях программы и деталях их взаимодействия. Такой код становится более
пере-используемым и модульным, уменьшает связность.
Внедрение зависимостей (Dependency Injection, DI) – одна из реализаций IoC.
При взаимодействии с другими модулями, программа оперирует высокоуровневыми
абстракциями, тогда как конкретная её реализация поставляется фреймворком
